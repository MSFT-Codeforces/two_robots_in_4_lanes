**Problem Statement**
You are playing osu!mania. A beatmap is given as a grid with `n` rows and `4` columns.  
Each row contains exactly one note, shown as `'#'` (all other cells are `'.'`).

Because notes closer to the bottom are processed earlier, you will process the rows in this order:
bottom row → ... → top row.

For each note `1, 2, ..., n` in the processing order, output the column number (from `1` to `4`) where the `'#'` appears.

**Input Format**
The first line contains an integer `t` (`1 ≤ t ≤ 100`) — the number of test cases.

For each test case:
- The first line contains an integer `n` (`1 ≤ n ≤ 500`) — the number of rows.
- The next `n` lines each contain exactly 4 characters, describing the rows from top to bottom.
  Each character is either `'.'` or `'#'`, and each row contains exactly one `'#'`.

It is guaranteed that the sum of `n` over all test cases does not exceed `500`.

**Output Format**
For each test case, output `n` integers on one line: the column indices of the notes in processing order (from the bottom row to the top row).

**Examples**
Sample Input 1
```
3
4
#...
.#..
..#.
...#
2
.#..
.#..
1
...#
```

Sample Output 1
```
4 3 2 1
2 2
4
```

**Editorial**
For each test case, read the `n` rows. Since notes are processed from bottom to top, iterate `i` from `n-1` down to `0`.  
In each row, find the position of `'#'` (there is exactly one), and output its 1-based column index.

Time complexity is `O(n * 4)` per test case, which is trivial under the constraints.

**Code**
```python
import sys

def solve() -> None:
    it = iter(sys.stdin.read().strip().splitlines())
    t = int(next(it))
    out_lines = []
    for _ in range(t):
        n = int(next(it))
        rows = [next(it).strip() for _ in range(n)]
        ans = []
        for i in range(n - 1, -1, -1):
            ans.append(str(rows[i].index('#') + 1))
        out_lines.append(" ".join(ans))
    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    solve()
```